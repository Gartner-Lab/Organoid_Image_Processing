%% process_segmentation_multipage
% 2020 January 05
% Jennifer Hu
% Process segmentations generated by ML pipeline. Fill in holes and
% concavities in organoid boundary, remove small regions, etc.
% Save data about organoid size, quantifications, etc.
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

%% Directory setup
if (~exist('const', 'var'))
    [const, consts] = constants();
end

% Edit these file paths to folder for saving files
savedir = '';
datadir = '';

swapRGstrings = {'mCh ','mCh_','GFPMO+mChLO'};
header_quantmulti = [{'Filename', 'Date', 'ECM', ...
    'Drug', 'Virus', 'Frame', 'Z', 'Adj', 'ZAreasL', 'ZAreasM'}, ...
    consts{strcmp(consts{1}, 'metrics')}];
header_frac = {'Filename', 'Date', 'ECM', ...
    'Drug', 'Virus', 'Frame', 'Z', 'Adj', 'Dist', 'LEP_Fraction'};

%% Edit this ---------------------------------------------------------------
exptsubdirs = ''; % folders to process


%% Prep data files ---------------------------------------------------------
exptdirs = fullfile(datadir, exptsubdirs); assert(all(isfolder(exptdirs)));
csvs = cellfun(@(x) sprintf('%s.csv', x), exptsubdirs, 'UniformOutput', 0);
datapaths = fullfile(datadir, 'cytoplasmic', csvs); fracpaths = fullfile(datadir, 'cytoplasmic', 'fractions', csvs);
c = '';
if any(isfile(datapaths)) || any(isfile(fracpaths))
    c = input('Overwrite existing, append, or cancel? (o/a/): ', 's');
    if isempty(c), return; end
end

%% Iterate over all masks in Cleaned and Simple
for i = 1:length(exptsubdirs)
    exptsubdir = exptsubdirs{i}; exptdir = exptdirs{i};
    previousdata = false; previousfrac = false;
    datapath = datapaths{i}; fracpath = fracpaths{i};
    if isempty(c) || strcmp(c, 'o')
    else
        % read csv files and find existing
        if isfile(datapath)
            previousdata = true;
            dataTable = readtable(datapath, 'Delimiter', ',', 'ReadVariableNames', true, 'HeaderLines', 0);
        end
        if isfile(fracpath)
            previousfrac = true;
            fracTable = readtable(fracpath, 'Delimiter', ',', 'ReadVariableNames', true, 'HeaderLines', 0);
        end
    end
    % start the timer
    tic

    %% Find every Simple and Cleaned file
    if ~isfolder(fullfile(exptdir, 'Centers')), mkdir(fullfile(exptdir, 'Centers')); end
    if ~isfolder(fullfile(exptdir, 'Cleaned')), mkdir(fullfile(exptdir, 'Cleaned')); end
    files_s = dir(fullfile(exptdir, 'Simple')); files_c = dir(fullfile(exptdir, 'Cleaned'));
    
    %% rename all to tiff before starting so names are consistent
    for j=1:length(files_s)
        if files_s(j).isdir, continue; end
        [~, imname, ext] = fileparts(files_s(j).name);
        if strcmp(ext, '.tif')
            newpath = fullfile(files_s(j).folder, [imname, '.tiff']);
            if isfile(newpath), continue; end
            movefile([files_s(j).folder, files_s(j).name], newpath);
            files_s(j).name = [imname, '.tiff'];
        end
    end
    for j=1:length(files_c)
        if files_c(j).isdir, continue; end
        [~, imname, ext] = fileparts(files_c(j).name);
        if strcmp(ext, '.tif')
            newpath = fullfile(files_c(j).folder, [imname, '.tiff']);
            if isfile(newpath), continue; end
            movefile(fullfile(files_c(j).folder, files_c(j).name), newpath);
            files_c(j).name = [imname, '.tiff'];
        end
    end
    
    %% Combine all masks names in case some haven't been cleaned yet
    imgs = unique({files_s.name, files_c.name}); n_imgs = length(imgs); assert(n_imgs > 0, 'No files found.');
    initialwritedone = false;
    for j=1:n_imgs
        % file stuff
        filename = imgs{j}; 
        if ~endsWith(filename, '.tiff'), continue; end
        brightness = fluor_brightness(filename);
        [~, imname, ext] = fileparts(filename);
        ntpsstr = extractAfter(imname, 'ntps');
        if contains(ntpsstr, 'x'), ntpsstr = extractBefore(ntpsstr, 'x'); end
        n_t = str2double(ntpsstr); if isnan(n_t), n_t = 1; end
        imgdataidx = []; imgfracidx = []; datatdone = []; fractdone = [];
        anyframeskipped = 0;
        appendmode = strcmp(c,'a');
        %% check whether to skip
        if appendmode
            if previousdata
                imgdataidx = strcmp(dataTable.Filename, filename); 
                if any(imgdataidx)
                    datatdone = dataTable.Z(arrayfun(@(x) ...
                        length(unique(dataTable.Adj(imgdataidx & dataTable.Frame == x))) == 3, 1:n_t));
                end
            end
            if previousfrac
                imgfracidx = strcmp(fracTable.Filename, filename);
                if any(imgfracidx)
                    fractdone = fracTable.Z(arrayfun(@(x) ...
                        length(unique(fracTable.Adj(imgfracidx & fracTable.Frame == x))) == 3, 1:n_t));
                end
            end
            anyframeskipped = ~(length(datatdone) == n_t && length(fractdone) == n_t);
            if ~anyframeskipped, continue; end
        end
        % print the current file and timer
        fprintf('\n%s - %s (%d of %d)', tocstring(), imname, j-2, n_imgs-2);
        %% find or make the cleaned segmentation
        file_cleaned = fullfile(exptdir, 'Cleaned', filename);
        if isfile(file_cleaned)
            cleaned_segmentation = open_multipage(file_cleaned, 0, n_t);
            n_z = size(cleaned_segmentation, 3);
        else
            files_segmentation = { fullfile(exptdir, 'Simple', filename), ...
                fullfile(boxdir, exptsubdir, 'masks', 'Simple', filename)};
            if any(isfile(files_segmentation))
                file_segmentation = files_segmentation{find(isfile(files_segmentation),1)};
            else
                fprintf(' not found: %s/%s\n', exptsubdir, filename);
                continue;
            end
            % open image
            [~, bfdata] = evalc('bfopen(file_segmentation)');
            n_s = length(bfdata{1,1});
            n_t = str2double(extractAfter(bfdata{1,1}{1,2}, 'T=1/'));
            n_z = str2double(extractBefore(extractAfter(bfdata{1,1}{1,2}, 'Z=1/'),';'));
            if isnan(n_t), n_t = 1; n_z = n_s; end
            assert(n_t*n_z == n_s, 'Must have correct number of slices.'); 
            cleaned_segmentation = zeros([size(bfdata{1,1}{1}) n_z n_t]);
            % make a giant stacked mask of all slices
            alldmask = ilastik2dmask(cell2mat(bfdata{1,1}(:,1)), const);
            if contains(imname, swapRGstrings)
                % swap red and green pixels if mCh
                swapped = alldmask;
                R = swapped == const.pxtype_dmask.M; G = swapped == const.pxtype_dmask.L;
                swapped(R) = const.pxtype_dmask.L; swapped(G) = const.pxtype_dmask.M;
                alldmask = swapped;
            end
            nrow = size(cleaned_segmentation, 1); i_s = 1;
            for k = 1:n_t % clean all slices
                for l = 1:n_z
                    % subset the big matrix using number of rows
                    dmask = alldmask((nrow*(i_s-1)+1):(nrow*i_s), :);
                    if any(dmask ~= const.pxtype_dmask.E, 'all')
                        cleaned_segmentation(:,:,l,k) = clean_segmentation(dmask, const);
                    end % otherwise leave all zeros
                    if i_s == 1
                        imwrite(cleaned_segmentation(:,:,l,k)+1, const.cmap_dmask, file_cleaned, ...
                            'tif', 'Compression', 'none');
                    else
                        % append to multi-page tiff
                        imwrite(cleaned_segmentation(:,:,l,k)+1, const.cmap_dmask, file_cleaned, ...
                            'tif', 'Compression', 'none', 'WriteMode', 'append');
                    end
                    if mod(i_s, round(n_s/10)) == 0
                        fprintf('.');
                    end
                    i_s = i_s + 1;
                end
            end
            fprintf(' cleaned - %s\n', tocstring());
        end

        %% quantify the cleaned segmentation
        % initialize numeric matrics
        datarows = 0; fracrows = 0;
        datamatrix = NaN(3*n_t,length(header_quantmulti)-5-1); bboxes = cell(3*n_t,1);
        fraclen = 3*n_t*100; fracmatrix = NaN(fraclen, length(header_frac)-5);
        % first dimension is z, second is t
        pixelcounts = squeeze(sum(sum(cleaned_segmentation ~= const.pxtype_dmask.E,1),2));
        previous_center = 0;
        for k = 1:n_t
            if appendmode && ismember(k, datatdone) && ismember(k, fractdone), continue; end % skip this frame
            ZAreasL = squeeze(sum(cleaned_segmentation(:,:,:,k) == const.pxtype_dmask.L, 'all'));
            ZAreasM = squeeze(sum(cleaned_segmentation(:,:,:,k) == const.pxtype_dmask.M, 'all'));

            %% Prepare center (largest) slice for image processing
            % do this by counting up cell pixels in 2D then finding max in 3D
            [pxcount, largest_slice] = max(pixelcounts(:,k));
            large_slices = find(abs(pixelcounts(:,k) - pxcount) < 0.15*pxcount);
            % for slices that are the same or within some px of each other
            if length(large_slices) > 1
                if (previous_center > 0)
                    % whichever is closest to the previous
                    [~, closest] = min(abs(large_slices - previous_center));
                    largest_slice = large_slices(closest);
                else
                    % the median of the almost equally-sized slices
                    largest_slice = median(large_slices);
                    if round(largest_slice) ~= largest_slice
                        % choose the bigger one
                        [~, x] = max(pixelcounts([largest_slice-0.5, largest_slice+0.5],k));
                        largest_slice = largest_slice + (x-1.5);
                    end
                end
            end
            previous_center = largest_slice;

            %% Generate metrics for multiple slices
            centeravg = zeros([size(cleaned_segmentation(:,:,1,1)),3]);
            file_center = fullfile(exptdir, 'Centers', filename);
            quantslices = (-1:1)+largest_slice;
            valid_adjs = quantslices(quantslices > 1 & quantslices <= size(cleaned_segmentation, 3));
            for z = valid_adjs
                %% Save images first... as long as we haven't skipped any frames
                zdmask = cleaned_segmentation(:,:,z,k);
                if ~anyframeskipped
                    if z == min(valid_adjs), centeravg = ilastik2rgb(zdmask, const); 
                    else % center average timelapse (RGB)
                        centeravg = centeravg + ilastik2rgb(zdmask, const);
                        if z == max(valid_adjs)
                            centeravg = centeravg/length(valid_adjs);
                            if k == 1
                                imwrite(centeravg, strrep(file_center, '.tiff', '(avg).tiff'), 'Compression', 'none');
                            else
                                imwrite(centeravg, strrep(file_center, '.tiff', '(avg).tiff'), 'Compression', 'none', 'WriteMode', 'append');
                            end
                        end
                    end
                    if z == largest_slice
                        % center timelapse
                        if k == 1
                            imwrite(zdmask+1, const.cmap_dmask, file_center, 'tiff', 'Compression', 'none');
                        else
                            imwrite(zdmask+1, const.cmap_dmask, file_center, 'tiff', 'Compression', 'none', 'WriteMode', 'append');
                        end
                    end
                end

                %% Write data to matrices
                do_data1 = 1; do_data2 = 1; adj = z-largest_slice;
                if appendmode
                    % skip quantification of this slice if done in both files
                    if ~isempty(imgdataidx), do_data1 = ~ismember(adj, dataTable.Adj(imgdataidx & dataTable.Frame == k)); end
                    if ~isempty(imgfracidx), do_data2 = ~ismember(adj, fracTable.Adj(imgfracidx & fracTable.Frame == k)); end
                    if ~(do_data1 || do_data2), continue; end
                end
                quantification = quantify_dmask(zdmask, const);
                assert(length(quantification.metric_row) == const.n_metrics-1);
                if do_data1
                    datamatrix(datarows+1,:) = [k, largest_slice, adj, ZAreasL, ZAreasM, ...
                        quantification.metric_row];
                    bboxes{datarows+1} = regexprep(num2str(quantification.bounds),'\s*','-');
                    datarows = datarows+1;
                end
                nfracs = size(quantification.LEPfracs, 2);
                if nfracs > 1 && do_data2
                    % append extra if needed
                    if fracrows + nfracs > fraclen
                        fracmatrix = [fracmatrix; NaN(fraclen, size(fracmatrix,2))];
                        fraclen = fraclen * 2;
                    end
                    fracdata((fracrows+1):(fracrows+nfracs),:) = ...
                        [repmat([k, largest_slice, adj], nfracs, 1), ...
                        quantification.LEPfracs'];
                    fracrows = fracrows + nfracs;
                end
            end
        end
        %% Add metadata for this file to the table along with the metrics
        % get metadata items: 3, 7, 8, 9 (four total)
        %     metadata = {chL, chM, date, time, strain, confluence, ECM, drug, virus, FDG, CD10};
        metadata_array = extract_metadata(exptdir, filename, [], consts);
        % make tables
        newdataTable = horzcat(cell2table(repmat({filename, metadata_array{[3,7,8,9]}}, datarows, 1), ...
            'VariableNames', header_quantmulti(1:5)), ...
            array2table(datamatrix(1:datarows,:), 'VariableNames', header_quantmulti(6:(end-1))), ...
            cell2table(bboxes(1:datarows,1), 'VariableNames', {'Bounding_Box'}));
        newfracTable = horzcat(cell2table(repmat({filename, metadata_array{[3,7,8,9]}}, fracrows, 1), ...
            'VariableNames', header_frac(1:5)), ...
            array2table(fracmatrix(1:fracrows,:), 'VariableNames', header_frac(6:end)));
        % Save the files
        backup(datapath); backup(fracpath);
        if initialwritedone || (appendmode && previousdata)
            writetable(newdataTable, datapath, 'WriteMode', 'Append', ...
                'WriteVariableNames', false);
        else
            writetable(newdataTable, datapath);
        end
        if initialwritedone || (appendmode && previousfrac)
            writetable(newfracTable, fracpath, 'WriteMode', 'Append', ...
                'WriteVariableNames', false);
        else
            writetable(newfracTable, fracpath);
        end
         initialwritedone = true;
    end
    fprintf('\n\nFinished %s after %s.\n\n', exptsubdir, tocstring());
end
